<!DOCTYPE html>
<html lang="en">
<head>
    <title>THE LOST FILES</title>
    <link rel="stylesheet" href="/fontawesome-free-5.15.4-web/css/all.css">
<!-- Load the custom CSS style file -->
<link rel="stylesheet" type="text/css" href="/style.css">
</head>
<body>
    <main class="main-container">

    <div class="popup-button-container">
                <button class="popup-button">ADD SONG</button>
    </div>
        <div class="overlay"></div>
        <div class="popup">
            <iframe class="popup-iframe" src="/add_tracks" title="ADDTRACKS"></iframe>
        </div>  
        <div class="edit-playlist-button-container">
          <button class="edit-playlist-button" onclick="toggleEditMode()">Edit Playlist OFF</button>

        </div>
        <div class="playlist-list-container">
            <ul class="playlist-list">
                <% data.json.forEach(function callback(element, index) { %>
                    <li class="playlist-list-item<%=index%>" onclick="handleListClick( <%= index %> )"><%= element.name %> </li>
                    <% }); %>
 
                </ul>
        </div>
          <div class="playlist-songs-container">
            <ol class="list" id ="list">
            
                    
                </ol>
          </div>
    </div>


    <div class="player">

        <!--Section for displaying details-->
        <div class="details">
            <div class="now-playing">Playing x of y</div>
            <div class="track-art"></div>
            <div class="track-name">Track Name</div>
            <div class="track-artist">Track Artist</div>
        </div>
    </div>
    <div class="buttons">
        
    </div>

    <!--Seek Slider-->
    <div class="slider_container">
        <div class="current-time">00:00</div>
        <input type="range" min="1" max="100" value="0"
            class="seek_slider" onchange="seekTo()">
        <div class="total-duration">00:00</div>
        <div class="prev-track" onclick="prevTrack()">
          <i class="fa fa-step-backward fa-2x"></i>
      </div>
      <div class="playpause-track" onclick="playpauseTrack()">
          <i class="fa fa-play-circle fa-5x"></i>
      </div>
      <div class="next-track" onclick="nextTrack()">
          <i class="fa fa-step-forward fa-2x"></i>
      </div>
    </div>

    <script type="text/javascript">
        var playlist_songs = [];
        var currentPlaylist = 0;
        var datajson = <%- JSON.stringify(data.json) %>;
        let now_playing = document.querySelector(".now-playing");
        let track_art = document.querySelector(".track-art");
        let track_name = document.querySelector(".track-name");
        let track_artist = document.querySelector(".track-artist");
          
        let playpause_btn = document.querySelector(".playpause-track");
        let next_btn = document.querySelector(".next-track");
        let prev_btn = document.querySelector(".prev-track");
          
        let seek_slider = document.querySelector(".seek_slider");
        let volume_slider = document.querySelector(".volume_slider");
        let curr_time = document.querySelector(".current-time");
        let total_duration = document.querySelector(".total-duration");
        let playlistData = document.querySelector(".list");
        const popup_button = document.querySelector(".popup-button");
        const overlay = document.querySelector(".overlay");
        const popup = document.querySelector(".popup"); 
        let list_items = document.querySelectorAll(".playlist-songs-item");
        const list_container = document.querySelector(".playlist-songs-container");
        let edit_playlist_button = document.querySelector(".edit-playlist-button");
        let track_list = datajson[currentPlaylist].data; 
        let playlistDisplaying = false;
        let scrollAdder = 0;
        var track_index = 0;
        let isPlaying = false;
        let updateTimer;
        var droppedElementId = 0;
        var draggingElementId = 0;
        var dragStartPosition = 0;
        var dragEndPosition = 0;
        var editMode = false;

        // Create the audio element for the player
        let curr_track = document.createElement('audio');
 
        popup_button.addEventListener("click", function() {
            overlay.style.display = "block";
            popup.style.display = "block";
        });

        overlay.addEventListener("click", function() {
            overlay.style.display = "none";
            popup.style.display = "none";
        });        
        

        //Functions

        function loadTrack(track_index) {
            // Clear the previous seek timer
            clearInterval(updateTimer);
            resetValues();
            console.log("loadTrack: " + track_index);
                                                                              //May be able to rework this using playlistdata.id
            var current_track = track_id_finder(track_index);
            console.log("current track: " + current_track);

            // Load a new track
            curr_track.src = track_list[current_track].path;
            curr_track.load();
            // Update details of the track
            track_art.style.backgroundImage = 
               "url(" + track_list[current_track].image + ")";
            track_name.textContent = track_list[current_track].name;
            track_artist.textContent = track_list[current_track].artist;
            now_playing.textContent = 
               "PLAYING " + (Number(track_index) + 1) + " OF " + track_list.length;
            
            // Set an interval of 1000 milliseconds
            // for updating the seek slider
            updateTimer = setInterval(seekUpdate, 1000);
            
            // Move to the next track if the current finishes playing
            // using the 'ended' event
            curr_track.addEventListener("ended", nextTrack);
            
            // Apply a random background color
            random_bg_color();
        }
            
          function random_bg_color() {
            // Get a random number between 64 to 256
            // (for getting lighter colors)
            let red = Math.floor(Math.random() * 256) + 64;
            let green = Math.floor(Math.random() * 256) + 64;
            let blue = Math.floor(Math.random() * 256) + 64;
            
            // Construct a color withe the given values
            let bgColor = "rgb(" + red + ", " + green + ", " + blue + ")";
            
            // Set the background to the new color
            document.body.style.background = bgColor;
          }
            
          // Function to reset all values to their default
          function resetValues() {
            curr_time.textContent = "00:00";
            total_duration.textContent = "00:00";
            seek_slider.value = 0;
          }
        
          function playpauseTrack() {
            // Switch between playing and pausing
            // depending on the current state
            if (!isPlaying) playTrack();
            else pauseTrack();
          }
            
          function playTrack() {
            // Play the loaded track
            curr_track.play();
            isPlaying = true;
            
            // Replace icon with the pause icon
            playpause_btn.innerHTML = '<i class="fa fa-pause-circle fa-5x"></i>';
          }
            
          function pauseTrack() {
            // Pause the loaded track
            curr_track.pause();
            isPlaying = false;
            
            // Replace icon with the play icon
            playpause_btn.innerHTML = '<i class="fa fa-play-circle fa-5x"></i>';
          }
            
          function nextTrack() {
            // Go back to the first track if the
            // current one is the last in the track list
            if (track_index < track_list.length - 1)
              track_index += 1;
            else track_index = 0;
            console.log("nextTrack: " + track_index);
            
            // Load and play the new track
            loadTrack(track_index);
            playTrack();
          }
            
          function prevTrack() {
            // Go back to the last track if the
            // current one is the first in the track list
            if (track_index > 0)
              track_index -= 1;
            else track_index = track_list.length - 1;
              
            // Load and play the new track
            loadTrack(track_index);
            playTrack();
          }
        
          function seekTo() {
            // Calculate the seek position by the
            // percentage of the seek slider 
            // and get the relative duration to the track
            seekto = curr_track.duration * (seek_slider.value / 100);
            
            // Set the current track position to the calculated seek position
            curr_track.currentTime = seekto;
          }
            
          function setVolume() {
            // Set the volume according to the
            // percentage of the volume slider set
            curr_track.volume = volume_slider.value / 100;
          }
            
          function seekUpdate() {
            let seekPosition = 0;
            
            // Check if the current track duration is a legible number
            if (!isNaN(curr_track.duration)) {
              seekPosition = curr_track.currentTime * (100 / curr_track.duration);
              seek_slider.value = seekPosition;
            
              // Calculate the time left and the total duration
              let currentMinutes = Math.floor(curr_track.currentTime / 60);
              let currentSeconds = Math.floor(curr_track.currentTime - currentMinutes * 60);
              let durationMinutes = Math.floor(curr_track.duration / 60);
              let durationSeconds = Math.floor(curr_track.duration - durationMinutes * 60);
            
              // Add a zero to the single digit time values
              if (currentSeconds < 10) { currentSeconds = "0" + currentSeconds; }
              if (durationSeconds < 10) { durationSeconds = "0" + durationSeconds; }
              if (currentMinutes < 10) { currentMinutes = "0" + currentMinutes; }
              if (durationMinutes < 10) { durationMinutes = "0" + durationMinutes; }
            
              // Display the updated duration
              curr_time.textContent = currentMinutes + ":" + currentSeconds;
              total_duration.textContent = durationMinutes + ":" + durationSeconds;
            }
          }

          function handleListClick(index) {
            displaySongs(index);
            changeListTextColor(index);
            currentPlaylist = index;
            playlistDisplaying = true;
            addDrag();
          }

        const initSortableList = (e) => {
          e.preventDefault();
          const draggingItem = document.querySelector(".dragging");
          // Getting all items except currently dragging and making array of them
          let siblings = [...list.querySelectorAll(".playlist-songs-item:not(.dragging)")];
          // Finding the sibling after which the dragging item should be placed
          //scrollAdder = list_container.scrollTop;
          let nextSibling = siblings.find(sibling => {
          

            //Logic for scrolling
            if ((e.clientY > (list_container.offsetHeight + list_container.offsetTop) * 0.8)) {
              if (list_container.scrollTop < playlistData.clientHeight - list_container.offsetHeight) {
                list_container.scrollTop += 1;
                console.log(list_container.scrollTop);
              }

            } 
            if ((e.clientY < (list_container.offsetHeight + list_container.offsetTop) / 2)) {
              if (list_container.scrollTop >= 0) {
              list_container.scrollTop -= .5;
              }

            }

            

            return e.clientY + list_container.scrollTop <= sibling.offsetTop + sibling.offsetHeight;
          });

          // Inserting the dragging item before the found sibling   
            if (nextSibling == undefined) {
              droppedElementId = track_list.length-1;
            } else {
              droppedElementId = nextSibling.id;
            }
            draggingElementId = draggingItem.id;

            list.insertBefore(draggingItem, nextSibling);

        }
        //event listeners for playlistdata
        playlistData.addEventListener("drop", (event) => {
          reorderPlaylist(draggingElementId, droppedElementId);
          recolorPlaylist();
          console.log("reload track: "+ track_index);
          reloadTrack(track_index);
        });
        
        //playlistData.addEventListener("dragover", initSortableList);
        //playlistData.addEventListener("dragenter", e => e.preventDefault());
        

        function reloadTrack(track_index) {
          var current_track = track_id_finder(track_index);
          track_art.style.backgroundImage = 
               "url(" + track_list[current_track].image + ")";
            track_name.textContent = track_list[current_track].name;
            track_artist.textContent = track_list[current_track].artist;
            now_playing.textContent = 
               "PLAYING " + (track_index + 1) + " OF " + track_list.length;
        }
        
        function recolorPlaylist() {
          //recolor playlist so it is always alternating
          console.log(playlistData.childNodes);
          for(i = 0; i < playlistData.childNodes.length; i++) {
            if (i %2 == 0)
                      playlistData.childNodes[i].style.color = 'white';
            else {
              playlistData.childNodes[i].style.color = '#F072A9';
            }
          }
        }

        function reorderPlaylist(draggingElementId, droppedElementId) {
         const startPos = track_list[draggingElementId].index;
         const endPos = track_list[droppedElementId].index;
          if (startPos > endPos) { //moved up
            for (i = startPos - 1; i >= endPos; i--) {
              track_list.find(o => o.index === i).index = i+1;
            }
            track_list[draggingElementId].index = endPos;
            track_index = endPos;                                     
          } else {        //moved down
            for (i = startPos + 1; i < endPos; i++) {
              track_list.find(o => o.index === i).index = i-1;
            }
            track_list[draggingElementId].index = endPos-1;
            if (track_index == startPos)
              track_index = endPos-1;
          }          
        }


        function addDrag() {
          list_items = document.querySelectorAll(".playlist-songs-item");
          list_items.forEach(item => {
            item.addEventListener("dragstart", () => {
              setTimeout( () => item.classList.add("dragging"), 0);              
            dragStartPosition = item.offsetTop;
            });
            item.addEventListener("dragend", () => {
              item.classList.remove("dragging");
              dragEndPosition = item.offsetTop;
            });
         });
        }

        function changeListTextColor(index) {
          document.querySelector('.playlist-list-item' + currentPlaylist).style.color = '#F072A9';
          const name = '.playlist-list-item' + index;
          document.querySelector(name).style.color = 'white';

        }

        var handleSongClick = function(event) {                     //update this with probably a global var that keeps track of editMode on/off
          console.log(track_list[event.target.id].index);
          track_index = track_list[event.target.id].index;
          //track_index = event.target.id;        
          loadTrack(track_index);
          
        }

        function displaySongs(index) {
          for (i = 0; i < track_list.length; i++) {
            while(playlistData.firstChild) {
              playlistData.removeChild(playlistData.lastChild);
            }
          }
          track_list = datajson[index].data;
          for (i = 0; i < track_list.length; i++) {
            const elem = track_list.find(o => o.index === i);
            var li = document.createElement('li');
            li.className = "playlist-songs-item";
            li.draggable = true;
            li.innerText = elem.name;
            li.id = i;
            //li.addEventListener('click', (event) => handleSongClick(event));          //use this to make onclick for li
            if (i %2 == 0)                                                                         //mainly remove event listeners
              li.style.color = 'white';
            playlistData.appendChild(li);
          }
          playlistData.addEventListener('click', handleSongClick, true);
        }

        function track_id_finder(track_index) {
          console.log(track_list);
          console.log("track_finder index: " + track_index);
          return track_list.find(o => o.index == track_index).id;
        }

        function toggleEditMode() {
            editMode = !editMode;
            console.log(editMode);
            //addDrag();              //need remove drag and remove onclick
            if (editMode) {
              edit_playlist_button.textContent = "Edit Playlist ON";
              playlistData.addEventListener("dragover", initSortableList);
              playlistData.addEventListener("dragenter", e => e.preventDefault());
              playlistData.removeEventListener('click', handleSongClick, true);
              
            } else {
              edit_playlist_button.textContent = "Edit Playlist OFF";
              playlistData.removeEventListener("dragover", initSortableList);
              playlistData.removeEventListener("dragenter", e => e.preventDefault());
              playlistData.addEventListener('click', handleSongClick, true);
            }
        }



        




          // Load the first track in the tracklist
        loadTrack(track_index);</script>
    </main>
</body>

</html>